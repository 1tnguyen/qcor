#include "token_collector_util.hpp"
#include "token_collector.hpp"
#include "xacc.hpp"
#include "xacc_service.hpp"

#include "AllGateVisitor.hpp"

namespace qcor {

void set_verbose(bool verbose) { xacc::set_verbose(verbose); }
void info(const std::string &s) { xacc::info(s); }

std::pair<std::string, std::string>
run_token_collector(clang::Preprocessor &PP, clang::CachedTokens &Toks,
                    const std::string &function_prototype) {

  if (!xacc::isInitialized()) {
    xacc::Initialize();
  }

  auto all_token_collectors = xacc::getServices<TokenCollector>();
  auto all_compilers = xacc::getServices<xacc::Compiler>();
  std::string kernel_src = "", compiler_name = "";

  for (auto &tc : all_token_collectors) {
    xacc::info("Running the " + tc->name() + " token collector");
    std::stringstream tmp_ss;
    (*tc).collect(PP, Toks, tmp_ss);

    if (xacc::hasCompiler(tc->name())) {
      auto compiler = xacc::getCompiler(tc->name());

      kernel_src =
          "__qpu__ " + function_prototype + " {\n" + tmp_ss.str() + " }";
      if (compiler->canParse(kernel_src)) {
        xacc::info(compiler->name() + " could parse tokens generated by " +
                   tc->name());
        compiler_name = compiler->name();
        return std::make_pair(kernel_src, compiler_name);
      } else {
        xacc::info(compiler->name() + " could not parse the tokens.");
      }
    }
  }

  // if we make it here, its not good
  xacc::error("[qcor] Invalid QCOR kernel expression, could not parse with "
              "available SyntaxHandlers / XACC Compilers.");
  return std::make_pair(kernel_src, compiler_name);
}

using namespace xacc::quantum;

class qrt_mapper : public AllGateVisitor {
protected:
  std::stringstream ss;

public:
  auto get_new_src() { return ss.str(); }

  void visit(Hadamard &h) override {
    ss << "quantum::h(" << h.getBufferNames()[0] << "[" << h.bits()[0]
       << "]);\n";
  }
  void visit(CNOT &cnot) override {
    ss << "quantum::cnot(" << cnot.getBufferNames()[0] << "[" << cnot.bits()[0]
       << "], " << cnot.getBufferNames()[1] << "[" << cnot.bits()[1] << "]);\n";
  }

  void visit(Rz &rz) override {}
  void visit(Ry &ry) override {}
  void visit(Rx &rx) override {}
  void visit(X &x) override {}
  void visit(Y &y) override {}
  void visit(Z &z) override {}
  void visit(CY &cy) override {}
  void visit(CZ &cz) override {}
  void visit(Swap &s) override {}
  void visit(CRZ &crz) override {}
  void visit(CH &ch) override {}
  void visit(S &s) override {}
  void visit(Sdg &sdg) override {}
  void visit(T &t) override {}
  void visit(Tdg &tdg) override {}
  void visit(CPhase &cphase) override {}
  void visit(Measure &measure) override {
    ss << "quantum::mz(" << measure.getBufferNames()[0] << "[" << measure.bits()[0]
       << "]);\n";
  }
  void visit(Identity &i) override {}
  void visit(U &u) override {}
  void visit(IfStmt &ifStmt) override {}
};

void map_xacc_kernel_to_qrt_calls(const std::string &kernel_str, const std::string& qpu_name,
                                  const std::string &compiler_name,
                                  const std::string &kernel_name,
                                  std::vector<std::string> bufferNames,
                                  llvm::raw_string_ostream &OS, int shots) {
  auto compiler = xacc::getCompiler(compiler_name);
  auto kernel = compiler->compile(kernel_str)->getComposites()[0];

  auto visitor = std::make_shared<qrt_mapper>();

  xacc::InstructionIterator iter(kernel);
  while (iter.hasNext()) {
    auto next = iter.next();
    if (!next->isComposite()) {
      next->accept(visitor);
    }
  }

  auto code = visitor->get_new_src();

  std::cout << "HELLO: " << code << "\n";

  OS << "quantum::initialize(\""<< qpu_name << "\", \"" << kernel_name << "\");\n";
  if (shots > 0) {
      OS << "quantum::set_shots(" << shots << ");\n";
  }
  OS << code;
  OS << "quantum::submit(" << bufferNames[0] << ".results()";
  for (unsigned int k = 1; k < bufferNames.size(); k++) {
    OS << ", " << bufferNames[k] << ".results()";
  }
  OS << ");\n";
}

} // namespace qcor